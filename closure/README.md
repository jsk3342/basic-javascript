# 클로저

여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.
자바스크립트의 고유 개념이 아니라서 ECMAScript 명세에도 정의를 다루지 않습니다.

어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상

클로저를 이해하려면 실행 컨텍스트에 대한 이해가 선행되어야 합니다.

클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상 입니다. 

선언될 당시의 lexical environment는 실행 컨텍스트의 구성 요소 중 하나인 outerEnvironmentReference에 해당합니다. lexicalEnvironment의 environmentRecord와 outerEnvironmentReference에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해진다고 했습니다. 어떤 컨텍스트 A에서 선언한 내부함수 B의 실행 컨텍스트가 활성화된 시점에는 B의 outerEnvironmentReference가 참조하는 대상인 A의 LexicalEnvironment에도 접근이 가능합니다.
여기서 combination의 의미를 파악할 수 있습니다. 내부함수 B가 A의 LexicalEnvironment를 언제나 사용하는 것은 아닙니다. 내부함수에서 외부 변수를 참조하지 않는 경우라면 combination이라고 할 수 없습니다. 내부함수에서 외부 변수를 참조하는 경우에 한에서만 combination, 즉 선언될 당시의 lexicalEnvironment와의 상호관계가 의미 있을 것입니다. 

지금까지 파악한 내용에 따르면 클로저란 "어떤 함수 내에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상"이라고 불 수 있겠습니다. 아직은 확 와닿지 않네요. 실제 예제를 통해 좀 더 명확히 밝혀봅시다. 우선 외부함수에서 변수를 선언하고 내부함수에서 해당 변수를 참조하는 형태의 코드를 작성해 보겠습니다. outer123 참고

그런데 이상한 점이 있습니다. inner 함수의 실행 시점에서는 outer 함수는 이미 실행이 종료된 상태인데 outer 함수의 lexicalEnvironment에 어떻게 접근할 수 있는 걸까요? 이는 가비지 컬렉터의 동작 방식 때문입니다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다. 외부함수인 outer의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outer2를 실행함으로써 호출될 가능성이 열린 것이죠. 언젠가 inner 함수의 실행 컨텍스트가 활성화 되면 outerEnvironmentReference가 outer 함수의 lexicalEnvironment를 필요로 할 것이므로 수집 대상에서 제외됩니다. 그 덕에 inner 함수가 이 변수에 접근할 수 있는 것이죠.

클로저는 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이라고 했습니다. 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이란 외부 함수의 lexicalEnvironment가 가비지 컬렉팅되지 않는 현상을 말하는 것입니다. 이를 바탕으로 다시 정의하자면 클로저란 어떤 함수 A에서 선언한 변수a를 참조하는 내부함수 B를 외부로 전달한 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말합니다.
함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수, 이미 생명주기가 끝난 외부 함수의 벼수를 참조하는 함수, 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수.

외부로 전달이 곧 return만을 의미하는 것은 아닙니다.

## 클로저와 메모리 관리
클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다. 메모리 누수의 위험을 이유로 클로저 사용을 조심해야 한다거나 심지어 지양해야 한다고 주장하는 사람들도 있지만 메모리 소모는 클로저의 본질적인 특성일 뿐입니다. 오히려 이러한 특성을 정확히 이해하고 잘 활용하도록 노력해야 합니다. '메모리 누수'라는 표현은 개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우에는 맞는 표현이지만 개발자가 의도적으로 참조 카운트를 0이 되지 않게 설계한 경우는 '누수'라고 할 수 없겠죠. 과거에는 의도치 않게 누수가 발생하는 여러 가지 상황들이 있었지만 그중 대부분은 최근의 자바스크립트 엔지에서 발생하지 않거나 거의 발견하기 힘들어졌으므로 이제는 의도대로 설계한 '메모리 소모'에 대한 관리법만 잘 파악해서 적용하는 것으로 충분하다고 생각합니다. 

관리 방법은 정말 간단합니다. 클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다. 그렇다면 그 필요성이 사라진 시점에는 더는 메모리를 소모하지 않게 해주면 됩니다. 참조 카운트를 0으로 만들면 언젠가 GC가 수거해갈 것이고, 이때 소모됐던 메모리가 회수되겠죠. 참조 카운트를 0으로 만드는 방법은? 식별자에 참조형이 아닌 기본형 데이터를 할당하면 됩니다. 

## 클로저 활용 사례
## 디바운스 
짧은 시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, 프론트 엔드 성능 최적화에 큰 도움을 주는 기능 중 하나 입니다. 
scroll, wheel, mousemove, resize 등에 적용하기 좋습니다. 

## 질문 리스트

### 클로저란?

어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상

클로저는 공부가 더 필요하다. 이벤트 루프는 잘 설명했다

### 고차함수란?
### 일급 객체란?
### 디바운스란?