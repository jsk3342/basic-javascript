# 클로저

여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.
자바스크립트의 고유 개념이 아니라서 ECMAScript 명세에도 정의를 다루지 않습니다.

어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상

클로저를 이해하려면 실행 컨텍스트에 대한 이해가 선행되어야 합니다.

클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상 입니다. 

선언될 당시의 lexical environment는 실행 컨텍스트의 구성 요소 중 하나인 outerEnvironmentReference에 해당합니다. lexicalEnvironment의 environmentRecord와 outerEnvironmentReference에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해진다고 했습니다. 어떤 컨텍스트 A에서 선언한 내부함수 B의 실행 컨텍스트가 활성화된 시점에는 B의 outerEnvironmentReference가 참조하는 대상인 A의 LexicalEnvironment에도 접근이 가능합니다.
여기서 combination의 의미를 파악할 수 있습니다. 내부함수 B가 A의 LexicalEnvironment를 언제나 사용하는 것은 아닙니다. 내부함수에서 외부 변수를 참조하지 않는 경우라면 combination이라고 할 수 없습니다. 내부함수에서 외부 변수를 참조하는 경우에 한에서만 combination, 즉 선언될 당시의 lexicalEnvironment와의 상호관계가 의미 있을 것입니다. 

지금까지 파악한 내용에 따르면 클로저란 "어떤 함수 내에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상"이라고 불 수 있겠습니다. 아직은 확 와닿지 않네요. 실제 예제를 통해 좀 더 명확히 밝혀봅시다. 우선 외부함수에서 변수를 선언하고 내부함수에서 해당 변수를 참조하는 형태의 코드를 작성해 보겠습니다. outer123 참고

그런데 이상한 점이 있습니다. inner 함수의 실행 시점에서는 outer 함수는 이미 실행이 종료된 상태인데 outer 함수의 lexicalEnvironment에 어떻게 접근할 수 있는 걸까요? 이는 가비지 컬렉터의 동작 방식 때문입니다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다. 외부함수인 outer의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outer2를 실행함으로써 호출될 가능성이 열린 것이죠. 언젠가 inner 함수의 실행 컨텍스트가 활성화 되면 outerEnvironmentReference가 outer 함수의 lexicalEnvironment를 필요로 할 것이므로 수집 대상에서 제외됩니다. 그 덕에 inner 함수가 이 변수에 접근할 수 있는 것이죠.

클로저는 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이라고 했습니다. 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이란 외부 함수의 lexicalEnvironment가 가비지 컬렉팅되지 않는 현상을 말하는 것입니다. 이를 바탕으로 다시 정의하자면 클로저란 어떤 함수 A에서 선언한 변수a를 참조하는 내부함수 B를 외부로 전달한 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말합니다.
함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수, 이미 생명주기가 끝난 외부 함수의 벼수를 참조하는 함수, 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수.

외부로 전달이 곧 return만을 의미하는 것은 아닙니다.

## 클로저와 메모리 관리


## 질문 리스트

### 클로저란?

어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상

클로저는 공부가 더 필요하다. 이벤트 루프는 잘 설명했다
